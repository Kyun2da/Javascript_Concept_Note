## 호이스팅

선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.

주의 : 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.



## 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.



## 자바스크립트 타입

크게 원시타입과 객체타입으로 나뉜다.

원시타입에는 숫자타입, 문자열타입, 불리언타입, undefined타입, null타입, symbol 타입이 있다.

> 여기서 undefined는 개발자가 의도하지않은 비어있는 값을 나타내며, 흔히 자바스크립트가 변수를 초기화하는데 사용한다. 반면 null은 개발자가 의도적으로 비어있는 값을 표현할 때 사용한다.

원시타입은 immutable하지만 객체 타입은 mutable 하다.



## 옵셔널 체이닝 연산자

연산자 ?. 는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.



## null 병합 연산자

연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

|| 연산자와의 차이는 ||는 좌항이 (false, undefined, null, 0, -0, NaN, '')이어도 우항의 피연산자를 반환한다.



## 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.



## 메서드

메서드는 객체에 묶여 있는 함수를 의미한다.



## 원시값은 변경 불가능하다는 말

let을 예를 들어보자 값이 변경 가능한 것이 아닌가?

여기서 값을 재할당할 때를 살펴보자. 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시값을 가리키게된다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다. 즉 원래 값이 바뀌는 것이 아닌 참조하는 메모리 주소를 변경할 뿐이다.



## 객체는 변경 가능하다는 말

객체는 생성하고 관리하는 방식이 매우 복잡하고 비용이 많이들어서 효율적으로 사용하기 위해 변경 가능한 값으로 설계되어 있다. 또한 참조에 의한 전달이라 객체를 가리키는 변수의 메모리 주소는 바뀌지 않는다.



## 함수

함수는 일련의 과정을 문(statement)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.



## 함수 정의 방식

| 함수 정의 방식       | 예시                                                    |
| -------------------- | ------------------------------------------------------- |
| 함수 선언문          | function add (x, y){ <br /> return x + y;<br />};       |
| 함수 표현식          | var add = function (x, y){<br />  return x + y;<br />}; |
| Function 생성자 함수 | var add = new Function('x','y', 'return x+y');          |
| 화살표 함수(ES6)     | var add = (x,y) => x+y;                                 |

번외 : 함수 선언문으로 함수를 선언하면 런타임 이전에 함수 객체가 먼저 생성되지만 함수 표현식으로 함수를 정의하면 객체는 생성되지 않고 선언(변수 호이스팅)만 된다.

```js
// 함수 참조
console.dir(add);
console.dir(sub);

// 함수 호출
console.log(add(2, 5));
console.log(sub(2, 5));

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```



## 일급 객체

값의 성질을 갖는 객체



## 즉시 실행 함수

IIFE라고도 한다.

```js
(function(){
    var a = 3;
    var b = 5;
    return a * b;
}());
```



## 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수 라고 한다. 또한, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds);

```



## 순수 함수와 비 순수 함수

함수형 프로그래밍에서 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비 순수 함수라고 한다.



## 스코프

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.



## 스코프 체인

함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이는 스코프가 함수의 중첩에 의해 계층적으로 구조를 갖는다는것을 의미한다. 즉, 스코프 체인은 스코프가 계층적으로 연결된 것을 말한다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.



## 함수 레벨 스코프

지역 스코프는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.

```js
var x = 1;
if(true){
    var x = 10;
}

console.log(10); // 10
```



## 렉시컬 스코프

함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 방식을 렉시컬 스코프 또는 정적 스코프라고 한다.

함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.



## 전역 변수 사용의 문제점

- 암묵적 결합 : 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합은 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.
- 긴 생명주기 : 전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜기간 소비한다.
- 스코프 체인 상에서 종점에 존재 : 전역 변수의 검색 속도가 가장 느리다는 점이다.
- 네임스페이스 오염 : 자바스크립트는 파일이 분리되어 있다고 해도 전역 스코프를 공유한다. 따라서 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.



## 전역 변수의 사용을 억제하는 방법

- 지역변수 사용하기
- 즉시 실행 함수
- 네임스페이스 객체 사용
- 모듈 패턴
- es6 모듈



## var, let, const

var는 함수스코프이지만 let과 const는 블록스코프이다.



또한 let과 const는 선언단계와 초기화 단계가 분리되어 진행된다.

```js
// 런타임 이전에 선언 단계가 실행된다. 아직 변수가 초기화 되지않았다.
// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없다.
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1

```

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(TDZ)라고 한다.

또한 var 는 전역 변수로 선언할 경우, window의 프로퍼티지만, let과 const는 window의 프로퍼티가 아니다.

```js
var x = 1;
let y = 2;

console.log(window.x); // 1
console.log(x); // 1
console.log(window.y); // undefined
console.log(y); // 1
```



## 프로토타입

프로토타입 객체(줄여서 프로토타입)란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다.



## 프로토타입 체인

자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.



## strict mode

strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시키게 해준다.

적용하려면 전역의 선두 또는 함수 몸체의 선두에 'use strickt'; 를 추가한다.



## strict mode가 발생시키는 에러

- 암묵적 전역
- 변수, 함수, 매개변수의 삭제
- 매개변수 이름의 중복
- with 문의 사용





## this

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.





## this 바인딩은 함수 호출 방식에 의해 동적으로 결정

```js
// 객체 리터럴
const circle = {
    radius: 5,
    getDiameter() {
        return 2 * this.radius;
    }
};

console.log(circle.getDiameter()); // 10
```

객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle을 가리킨다.



```js
// 생성자 함수
function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.getDiameter = function() {
    return 2 * this.radius;
}

const circle = new Circle(5);
console.log(circle.getDiameter()); // 10
```

생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.



1. 일반함수로 호출된 모든 함수(중첩함수, 콜백함수 포함) 내부의 this에는 전역 객체가 바인딩 된다.
2. 메서드 내부의 this는 프로퍼티로 메서드를 가리키고 있는 객체와는 관계가 없고 메서드를 호출한 객체에 바인딩 된다.
3. 생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩 된다.
4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출은 첫번째 인수로 전달한 객체를 this로 바인딩한다.



## 실행 컨텍스트

실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 좀 더 구체적으로 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로 구성되며, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.



## 렉시컬 환경

렉시컬 환경은 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다. 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.



## 클로저

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.

일반적으로 모든 중첩함수를 클로저라고 생각할 수 있겠지만 보통 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.



## 클로저를 쓰는 이유

클로저는 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정함수에게만 상태 변경을 허용하기 위해 사용한다.



## 디바운스와 쓰로틀

일단 두가지 모두 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.



디바운스는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 후에 이벤트 핸들러가 한번만 호출되도록 한다. 즉, 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 **마지막에 한 번만 이벤트 핸들러가 호출**되도록 한다.



쓰로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 **일정 시간 간격으로 이벤트 핸들러를 호출**한다.



디바운스 : 입력 필드 자동완성 UI구현, 버튼 중복 클릭방지등에 쓰임

스로틀 : 스크롤 이벤트 처리나 무한 스크롤 UI구현등에 쓰임



## 싱글 스레드

자바스크립트 엔진의 실행 방식으로 한번에 하나의 태스크만 실행할 수 있다는 것을 의미한다.



## 동기 처리 방식 vs 비동기 처리 방식

현재 실행 중인 테스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 동기처리 라고한다.

현재 실행 중인 테스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고한다.



## 콜 스택

소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜스택이다.



## 힙

힙은 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.

메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야한다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정해야한다. 따라서 객체가 저장되는 메모리 공간의 힙은 구조화 되어 있지 않다는 특징이 있다.



## 테스크 큐

setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 테스크 큐와는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재한다.



## 이벤트 루프

이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 테스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.



## Ajax

Ajax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작한다. XMLHttpRequest는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.



## 프로미스

콜백 지옥을 해결하기 위해 등장한 ES6 함수이다.

프로미스의 상태는 resolve와 reject함수를 호출하는 것으로 결정된다.

프로미스가 생성된 직후 프로미스는 기본적으로 pending상태를 갖고있다. 이후 비동기 처리가 수행되면 비동기 처리 결과에 따라 다음과 같이 프로미스의 상태가 변경된다.

- 비동기 처리 성공 : resolve 함수를 호출해 프로미스를 fulfilled 상태로 변경한다.
- 비동기 처리 실패 : reject 함수를 호출해 프로미스를 rejected 상태로 변경한다.

이렇게 fullfilled 또는 rejected 상태를 settled 상태라고 한다. 즉 비동기처리가 수행된 상태이다.



## Promise.all vs Promise.race vs Promise.allSettled

일단 위의 세가지 메서드 모두 인수로 전달받은 프로미스를 동시에 실행한다.



Promise.all 메서드는 인수로 전달받은 배열의 프로미스중 하나라도 rejected 상태가 되면 나머지 프로미스가 fullfilled 상태가 되는 것을 기다리지 않고 종료한다.

Promise.race 메서드는 인수로 전달받은 메서드중 가장 먼저 fullfilled 상태가 된 프로미스의 처리 결과를 resolve 한다. 즉, race란 말처럼 프로미스끼리 경쟁을 한다고 볼 수 있다. 반면, 하나라도 reject 상태가 되면 Promise.all 과 동일하게 처리된다.]

Promise.allSettled 메서드는 모두 settled 상태가 되면 처리결과를 반환한다.



## 마이크로 태스크 큐

마이크로태스크 큐는 테스크 큐와는 별도의 큐다. 마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외의 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다. 콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로태스크 큐는 태스크 큐보다 우선 순위가 높다. 즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행한다. 이후 마이크로 태스크 큐가 비면 태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.

```js
setTimeout(() => console.log(1), 0);

Promise.resolve()
	.then(() => console.log(2))
	.then(() => console.log(3));
```



## fetch

fetch  함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API이다. XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다. fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.



## async await

제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리 처럼 동작하도록 구현할 수 있게 나온 것이 async await이다.

es8문법이다.

에러처리는 try catch 를  사용한다.

