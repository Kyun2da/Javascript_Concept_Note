# 호이스팅 (Hoisting)

여기서는 호이스팅이란 개념이 무엇인지 호이스팅이란 개념이 왜 나온 것인지에 대해 알아보도록 하자.



## 호이스팅이란?

호이스팅이란 변수나 함수의 선언이 함수 블록의 최상단으로 끌어올려지는 것을 말한다.

이 말이 무엇일까? 코드로 한번 이해해도록 해보자

```js
console.log(score);

var score; // 변수 선언문
```

만약 호이스팅이 일어나지 않는 다면 위의 console.log(score)는 score is not defined 를 내뱉어야 한다. 하지만 위의 코드에서 결과는 `undefined`가 된다.

이것을 바로 호이스팅이라고 한다. 호이스팅은 var, let, const, function, function* , class 등의 키워드를 사용해서 선언하는 모든 식별자가 호이스팅된다.



그렇다면 호이스팅이 일어나는 이유에 대해서 알아보도록하자.



## 호이스팅이 일어나는 이유

호이스팅이 일어나는 이유는 자바스크립트 엔진의 코드 실행 방식과 깊은 연관이 있다. 더 자세하게는 실행 컨텍스트에서 설명하도록 하고 여기서는 간단한 이유만 알아보도록 하자.

자바스크립트 엔진은 코드를 실행하기전에 **소스코드 평가 과정**을 갖는다. 

소스코드 평가 과정이란 코드를 실행 하기 전에 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행하는 단계이다. 실행 컨텍스트로 말하자면 실행컨텍스트를 생성하는 과정이라고 봐도 무방할 듯 하다.



## 호이스팅의 의문점. let과 const는 호이스팅이 안일어나지 않나?

정답부터 말하자면 호이스팅이 일어난다. 하지만 호이스팅이 안일어난 것처럼 동작한다고 할 수 있다.

```js
let foo = 1;

{
	console.log(foo); // ReferenceError : Cannot access 'foo' before initialization
    let foo = 2;
}
```

위의 코드를 살펴보자 

블록 스코프를 따르는 let은 위의 코드에서 위와 같이 에러를 보여주며 종료된다. 이는 이미 foo가 밑에 선언되어있다는 것을 자바스크립트 엔진은 알고 있다는 것이다. 바로 이것이 **호이스팅의 증거**이다.

또한 다시한번 var와 한번 비교를 통해 정확이 이러한 현상이 나타나는 이유를 살펴보자.

일반적으로 변수의 실행은 3단계로 나뉜다.

```js
var a = 1;
```

위의 코드를 예로 들어보자.

1. 선언 단계  var a;
2. 초기화 단계 a = undefined;
3. 할당 단계 a = 1;

이렇게 3단계로 나눌 수 있다. 바로 1단계와 2단계가 실행되는 것이 호이스팅이라고 할 수 있다.

하지만 let 은 하나의 암시적 단계가 더 존재한다.

```js
let a = 1;
```

1. 선언 단계 let a;
2. **일시적 사각지대(TDZ)** 
3. 초기화 단계 a = undefined
4. 할당 단계 : a = 1

바로 위와 같이 let이나 const 키워드는 스코프의 시작 지점부터 초기화단계 시작 지점까지 변수를 참조할 수 없다. 

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone)이라고 부른다.

이렇게 일시적 사각지대를 생성하여 자바스크립트 엔진은 let 과 const를 호이스팅이 일어나지 않는 것처럼 동작하게 하였다.











