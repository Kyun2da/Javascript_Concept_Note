# 자바스크립트가 데이터를 처리하는 방법

이 문서에서는 자바스크립트가 어떻게 변수를 선언하고 할당하는지에 대해 다뤄보려고 한다.



## 데이터 타입 종류

자바스크립트 데이터의 종류는 크게 두가지로 나눌 수 있다. 바로 **기본형 타입(primitive type)** 과 **참조형 타입(reference type)** 이다.

기본형 타입

- 숫자(number)
- 문자열(string)
- 불리언(boolean)
- null
- undefined
- symbol 등

참조형

- 객체
- 배열
- 함수
- 날짜
- 정규표현식
- Map
- WeakMap
- Set
- WeakSet 등



그렇다면 어떻게 원시형과 참조형을 나눌 수 있을까?

이를 나누는 핵심 개념은 바로 불변성(immutability)이다.

불변성은 변하지 않는 성질을 의미하는데

```js
var a = 'abc';
a = 'bcd';
```

위와 같은 코드를 보면 분명히 a는 값이 변경될 수 있는 것만 같다.

아래의 두 번째 섹션에서 좀더 자세히 어떻게 불변성을 설명할 수 있는지 알아보도록 하자.



## 원시타입이 데이터를 메모리에 할당하는 방법

```js
var a;
a = 'abc';
a = 'bcd';
```

위와 같은 코드가 있다고 해보자.

위 과정을 설명하기 위해선 실행컨텍스트의 개념을 먼저 아는 것이 좋지만 여기서는 어떻게 메모리에 할당되는지 그 원리만 알아보도록 하겠다.



일반적으로 자바스크립트는 변수영역과 데이터 영역이 존재한다.

자바스크립트 엔진은 데이터 a를 선언할 때 변수 영역에 변수의 이름을 선언하게 된다.

그 후 abc라는 값을 데이터 영역의 빈 메모리에 값을 넣고 해당 주소값을 변수 영역의 값에 넣게 된다.

그림으로 설명하자면 아래와 같다. 아래 그림은 위 두개의 행은 변수영역을 말하고, 아래 두 개의 행은 데이터 영역을 말한다.

|  주소  | ...  | 1002     | 1003                   | 1004     | 1005     | ...  |
| :----: | ---- | -------- | ---------------------- | -------- | -------- | ---- |
| 데이터 |      |          | 이름: a<br />값: @5004 |          |          |      |
|  주소  | ...  | **5002** | **5003**               | **5004** | **5005** | ...  |
| 데이터 |      |          |                        | abc      |          |      |

그렇다면 변수를 재할당할 때는 어떻게 변수 영역이 변할까?

|  주소  | ...  | 1002     | 1003                   | 1004     | 1005     | ...  |
| :----: | ---- | -------- | ---------------------- | -------- | -------- | ---- |
| 데이터 |      |          | 이름: a<br />값: @5005 |          |          |      |
|  주소  | ...  | **5002** | **5003**               | **5004** | **5005** | ...  |
| 데이터 |      |          |                        | abc      | bcd      |      |

위와 같이 5004번의 데이터 영역을 바꾸는 것이 아니라 새로 데이터를 만들어 그 주소값을 참조하는 형식으로 재할당이 이루어지게 된다.

왜 이런식으로 메모리의 값을 바꾸지 않고 새로운 메모리에 할당을 하게 될까?

이는 메모리를 좀더 효율적으로 사용하기 위한 아이디어 이다. abc를 참조하는 데이터가 a 하나라면 물론 이 작업이 비효율적일 수 있겠지만 엄청나게 많은 변수들이 똑같은 값을 가지고 있다면 불필요한 메모리의 사용량이 늘어나게 될 것이다. 그래서 자바스크립트는 중복된 값은 하나의 메모리 용량만 쓰게끔 이러한 방식을 채택하였다.

만약 해당 메모리를 참조하는 변수가 없다면, 자바스크립트 엔진은 가비지컬렉터를 이용해 참조 카운트가 0 인 아이들을 메모리 해제를 하도록 설계가 되어있다.

이러한 가비지 컬렉터는 프로그램이 실행되는 동안 내부적으로 계속 돌아가고 있다고 한다.

어찌 되었든 이러한 성질때문에 **primitive type은 한번 만든 값을 바꿀 수 없기 때문에 불변성의 성질을 갖고 있다**고 할 수 있다.

그럼 이제 Reference Type은 어떻게 메모리에 할당되는지 살펴보도록 하자



## Reference Type 데이터가 할당되는 방법

레퍼런스 타입과 원시 타입의 가장 큰 차이는 레퍼런스 타입은 객체의 변수(프로퍼티) 영역이 별도로 존재한다는 점이다.

```js
var obj1 = {
	a: 1,
    b: 'bbb'
};
obj.a = 2;
```

위의 코드로 데이터가 어떻게 할당되는지 살펴보도록 하자.

|  주소  | ...  | 1002      | 1003                      | 1004     | 1005     | ...  |
| :----: | ---- | --------- | ------------------------- | -------- | -------- | ---- |
| 데이터 |      |           | 이름: obj1<br />값: @5002 |          |          |      |
|  주소  | ...  | **5002**  | **5003**                  | **5004** | **5005** | ...  |
| 데이터 |      | @7103 ~ ? | 1                         | 'bbb'    | 2        |      |

위의 표는 객체의 변수영역과 데이터 영역을 나타낸 것이다.

아래의 표는 객체 @5002의 변수 영역을 나타낸 것이다.

|  주소  |          7103          |          7104          | 7105 | 7106 | 7107 | ...  |
| :----: | :--------------------: | :--------------------: | :--: | :--: | :--: | :--: |
| 데이터 | 이름: a<br />값: @5005 | 이름: b<br />값: @5004 |      |      |      |      |

위와 같이 객체는 주소 5002 처럼 프로퍼티 영역을 따로 마련하기 때문에 객체의 데이터 영역은 바뀌지 않게된다.

다만, 객체의 프로퍼티에는 다른 값을 얼마든지 대입할 수 있게되는 데 바로 이 부분 때문에 흔히 참조형 데이터는 불변하지 않다(mutable)라고 한다.



## 변수 복사비교

위에서 설명한 원시타입과 참조타입간의 차이는 변수를 복사할때 더 확실한 차이를 볼 수 있다.

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

위의 각각의 변수의 결과는 어떻게 될까?

```js
console.log(a); // 10
console.log(b); // 15
console.log(obj1); // { c: 20, d: 'ddd' }
console.log(obj2); // { c: 20, d: 'ddd' }
```

위와 같은 결과가 나오게 된다.

왜냐하면 원시타입은 변수를 재할당 하면서 새로운 메모리에 데이터를 할당하고 그 데이터를 참조하도록 b가 참조하는 주소를 변경하게 된다. 이렇게 되어 a 와 b는 다른 메모리를 가리키게 되는 것이다.

하지만 객체는 객체 프로퍼티를 가리키는 참조 영역은 obj1 과 obj2 가 obj2.c를 바꾸더라도 변경되지 않는다. 왜냐하면 obj2.c 의 참조영역만 바뀌기 때문에 결과적으로 obj1 과 obj2는 바뀐 값을 동일하게 참조한다고 볼 수 있다.



## 불변성

최근 불변성이 자바스크립트 진영에서 가장 중요한 개념중 하나로 떠오르고 있다.

그 이유는 크게 두가지로 볼 수 있는데

1. 무분별한 상태의 변경을 막는다.
2. 상태의 변경을 추적하기가 쉽다.

정도로 볼 수 있다.

이러한 불변성 개념을 지키기 위해, immer.js 등의 라이브러리도 나오고 있고 대표적으로 불변성을 개념을 이용한 Redux를 예로 들 수 도 있다.

여기서는 객체를 불변성으로 만드는 방법만 코드로 첨부해놓기로 하겠다.

```js
const copyObjectDeep = function(target) {
    let result = {};
    if (typeof target === 'object' && target !== null){
        for (const prop in target){
            result[prop] = copyObjectDeep(target[prop]);
        }
    } else{
        result = target;
    }
    return result;
}
```















